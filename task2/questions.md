# Control Questions

1. Сравнение clock_nanosleep и nanosleep : Почему для периодических задач в СРВ clock_nanosleep с абсолютным временем всегда предпочтительнее, чем относительный nanosleep ? Проиллюстрируйте проблему накопления ошибки на гипотетическом примере.
> clock_nanosleep всегда предпочтительнее для СРВ потому что не имеет накопление ошибки, процесс всегда будет запущен в точное определенное время, тогда как nanosleep не имеет такого преимущества, потому что зависит от предшествующего процесса. Пример: У нас есть процесс который должен выполнится через 1 секунду после старта программы, но перед ним есть еще 1 процесс, предположим что первый процесс задерживается и не успевает выполнится за 1 секунду, тогда, в случае с nanosleep, старт нужного нам процесса сместится, а в случае clock_nanosleep он запустится ровно через 1 секунду без задержек, даже если предыдуший процесс не успел завершиться.
2. timerfd vs Сигналы: POSIX-таймеры ( timer_create ) могут доставлять события через сигналы. Почему timerfd считается более надежным и предсказуемым механизмом для построения циклов обработки событий (event loops)?
> timerfd стабильнее и предсказуемей, он дает число срабатыванийю
его удобнее интрегрировать в систему, удобен для асихронных задач. Не нужно создавать отдельных потоков для таймера и для сигнала
3. Инверсия приоритетов: Хотя мы не реализовывали это напрямую, опишите сценарий, в котором использование pthread_mutex может привести к инверсии приоритетов. Какие атрибуты мьютекса (см. pthread_mutexattr_setprotocol ) помогают решить эту проблему?
> Инверсия приоритетов — это такой прикол:
> - Низкоприоритетный поток держит mutex
> - Высокоприоритетный поток хочет тот же mutex → блокируется
> - Средний поток (с более высоким приоритетом, чем низкий) активно работает и не даёт низкому потоку освободить mutex
> - В итоге самый важный поток стоит в очереди «из-за» менее важных
> 
> PTHREAD_PRIO_INHERIT (Priority Inheritance) Когда низкоприоритетный поток держит mutex, нужный высокому: → низкоприоритетный поток временно получает высокий приоритет, чтобы быстро закончить работу и освободить mutex.
4. Предсказуемость vs Производительность: Объясните, почему техники, использованные в задании 4 ( SCHED_FIFO , привязка к ядру), могут уменьшить общую производительность системы, но при этом повысить ее предсказуемость. 
> - Когда поток работает на SCHED_FIFO, он вытесняет ВСЕ обычные процессы. Он работает до тех пор, пока сам не заснёт  
> Это создаёт детерминизм, но снижает общую производительность системы — другим потокам CPU почти не достаётся.
> - Когда поток прибит к одному ядру, ядро уже не может:
>   - переносить задачи между ядрами,
>   - балансировать нагрузку,
>   - использовать CPU более эффективно.
>
> Производительность падает из-за отсутствия гибкости планировщика. Но зато та задача, которую ты измеряешь, работает ровно, без скачков.
5. Жесткое реальное время: Достаточно ли рассмотренных техник для построения системы жесткого реального времени на стандартном ядре Linux? Что такое PREEMPT_RT и какие фундаментальные изменения в ядре он вносит для обеспечения детерминизма?
> Обычное ядро Linux никогда не даёт гарантий в микросекундах или миллисекундах. Оно хорошо только для soft real-time.
> 
> PREEMPT_RT - это патч к ядру Linux, превращающий его почти в полноценную RTOS, он делает слудующее:
> - Почти весь kernel становится прерываемым, обычное ядро имеет большие неперерываемые участки. PREEMPT_RT уменьшает их до минимума.
> - Spinlock'и превращаются в mutex с приоритетами
> - IRQ-обработчики могут работать как kernel-threads
> - Жёстко ограничиваются источники непредсказуемости

