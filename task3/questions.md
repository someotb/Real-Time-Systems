# Control Questions

1. POSIX MQ vs. UNIX Sockets: В каких случаях вы бы предпочли использовать очередь сообщений, а в каких — сокеты? Опишите по одному сценарию для каждого.
> POSIX MQ подходит, когда важны:
> - короткие, структурированные сообщения;
> - приоритеты;
> - отсутствие необходимости в потоковом соединении.
>
> **Сценарий:** Диспетчер отправляет воркерам задания фиксированного формата через очередь сообщений, воркеры получают их по приоритету.
>
> UNIX Sockets подходит, когда нужно:
> - потоковое двустороннее соединение;
> - переменные размеры данных;
> - множество клиентов.
> 
> **Сценарий:** Локальный RPC-сервер принимает несколько клиентских соединений по > UNIX-сокету и передаёт произвольные объёмы данных.

2. Edge-Triggered (ET) vs. Level-Triggered (LT) в epoll : Опишите разницу в поведении epoll в режимах EPOLLET и EPOLLIN (по умолчанию). Какой режим сложнее в использовании и почему? Какие ошибки можно допустить при работе с ET?
> LT (EPOLLIN — по умолчанию)
> Событие генерируется, пока в сокете остаются непрочитанные данные. Если не дочитал — epoll снова уведомит.
> 
> ET (EPOLLET)
> Событие генерируется только при *изменении состояния* («данные > появились»). Если вычитать не всё — второго уведомления не будет.
> 
> ET сложнее, потому что требует полного чтения (read в цикле до > `EAGAIN`) и корректной работы с неблокирующими дескрипторами.
> 
> Возможные ошибки при ET:
> - чтение только одного раза вместо цикла «до EAGAIN» → потеря > событий;
> - неверная обработка `EAGAIN/EWOULDBLOCK`;
> - использование блокирующих сокетов;
> - неправильная обработка частичных записей при `write()`.

3. Семафоры vs. Мьютексы: В задании 4 мы использовали семафоры. Можно ли было использовать мьютекс ( pthread_mutex_t ) для синхронизации доступа к общей памяти между разными процессами? Объясните, почему да или нет, и какие атрибуты мьютекса для этого потребовались бы.
> Да, можно, при условии правильной инициализации. Требуемые атрибуты мьютекса: 
> ```c
> pthread_mutexattr_t attr;
> pthread_mutexattr_init(&attr);
> pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
> pthread_mutex_init(&mutex, &attr);
> ```

4. Копирование данных ядром: Расположите изученные механизмы (MQ, UNIX Sockets, Shared Memory) в порядке возрастания количества копирований данных между ядром и пользовательским пространством при передаче. Объясните свой ответ.

> 1. Shared Memory — меньше всего копирований
>       - Нет копирования ядром: оба процесса работают с одним и тем же участком памяти.
> 2. UNIX Sockets Обычно два копирования:
    >       - user → kernel
    >       - kernel → user 
> 3. POSIX Message Queues Фактически несколько копирований и больше накладных расходов:
>       - user → kernel
>       - kernel → очередь
>       - очередь → kernel
>       - kernel → user
