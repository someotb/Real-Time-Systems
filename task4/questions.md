# Control Questions

1. В чем принципиальное отличие символьных устройств от блочных? Приведите по два примера каждого типа.

> **Символьные устройства** (character devices) передают данные побайтно, поток непрерывный, нет буферизации блоков.
> **Примеры:** `/dev/tty0` (терминал), `/dev/input/event3` (клавиатура).
> **Блочные устройства** (block devices) работают с блоками фиксированного размера, данные можно читать/писать случайно, поддерживается кэширование.
> **Примеры:** `/dev/sda` (жесткий диск), `/dev/mmcblk0` (SD-карта).

2. Почему для ожидания событий от нескольких источников данных `poll()` является предпочтительнее, чем busy-wait цикл? Опишите сценарий, где это критически важно.

> `poll()` блокирует процесс до появления события на любом дескрипторе, что экономит CPU.
> **Сценарий:** сервер, одновременно обслуживающий десятки устройств ввода или сокетов; busy-wait будет потреблять 100% CPU, в то время как `poll()` ждет событий эффективно.

3. Может ли вызов `read()` для символьного устройства заблокировать процесс? Если да, то как этого избежать?

> Да, `read()` может блокировать, если данные еще не поступили.
> **Как избежать:**
>
> * открыть дескриптор с `O_NONBLOCK` (неблокирующий режим);
> * использовать `poll()`/`select()`/`epoll()` для проверки наличия данных перед `read()`.

4. Объясните, почему для работы с `ioctl` и структурами из `/dev/input/` требуются специфичные для Linux заголовочные файлы. Является ли такой код переносимым на другие POSIX-системы (например, macOS или FreeBSD)?

> Структуры `struct input_event` и константы (`EV_KEY`, `EVIOCGNAME` и т.д.) определены только в Linux (`<linux/input.h>`).
> Такой код **не переносим** напрямую: macOS и FreeBSD имеют другие драйверы устройств, другие ioctl-коды и структуры, POSIX стандарт их не описывает.
