# Repository with laboratory work on the subject of Real-time systems
> Group: IA-331 | 
Student: Liubimov Kirill  
[Theory for laboratory works](https://gitverse.ru/aloshkarev/realtime-systems/content/master/tasks)

# Task 1:
## Задачи по организации доступа к общему ресурсу некоторого числа параллельных процессов

1. Выполнение программы "Hello World" (hello.c) 
2. Знакомство с организацией работы потоков, pthreads (intro.c)
3. Организация доступа к разделяемому ресурсу 
    - Дополнить код nomutex.c решением проблемы доступа к ресурсу с помощью мьютексов (mutex.c) 
    - Знакомство с организацией доступа к общему ресурсу с помощью семафоров (semex.c) 
    - Дополнить код condvar.c решением проблемы доступа к ресурсу с помощью условных переменных. Подробности задания в комментариях кода. (condvar.c)
    - Пример решения организации доступа в задаче "Производитель-потребитель" 
4. Инверсия приоритетов 
    - Используя исходные коды working.h, working.c, и scenario_1.c, проверить на практике пример возникновения проблемы "Инверсия приоритетов" 
    - Дополнить код scenario_2.c решением проблемы "Инверсия приоритетов" 
5. Прерывания 
    - Дополнить код intsimple.c возможностью обработки прерываний с клавиатуры и сигналов (SIGTERM, SIGKILL, SIGUSR1, SIGUSR2) (intsimple.c) 
6. Завершить разработку программы "Менеджер ресурсов" (Подробности задания в исходном коде). 
7. Проверить работу реализовав простой клиент. (resmgr.c)

# Task 2:
## Основы времени и периодических задач
### Задание 1: Анализ системных часов (`calctime1.c`, `calctime2.c`)

- **Цель:** Понять разницу между `CLOCK_REALTIME` и `CLOCK_MONOTONIC`, научиться создавать стабильный периодический цикл с помощью `clock_nanosleep`.

- **Действия:**
    1. Изучите `calctime1.c` (предоставлен для анализа). Обратите внимание, как измеряется разрешение часов.
    2. Модифицируйте `calctime2.c`:
        - Реализуйте цикл, который просыпается каждые 2 миллисекунды с использованием  
        `clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ...)`.
        - Собирайте статистику реальных интервалов между пробуждениями (дельт).
        - Рассчитайте и выведите **min/max/avg** и **стандартное отклонение**, чтобы оценить стабильность периода.
    3. В комментариях к коду объясните, почему `TIMER_ABSTIME` критически важен для предотвращения накопления ошибки (дрейфа таймера).

### Задание 2: Периодический таймер на `timerfd` (`reptimer_timerfd.c`)

- **Цель:** Освоить современный Linux API (`timerfd`) для создания периодических событий без использования сигналов.

- **Действия:**
    1. Реализуйте программу, которая создает таймер `timerfd`.
    2. Настройте его на первое срабатывание через 5 секунд, а затем периодически каждые 1500 мс.
    3. В цикле ожидайте событий от таймера с помощью `read()` и выводите количество истечений и текущее время.
    4. В комментариях к коду сравните подходы с `clock_nanosleep` и `timerfd`. В каких случаях `timerfd` предпочтительнее? (Подсказка: интеграция с `epoll`).

---

### Задание 3: Стратегии обработки таймаутов (`timeout_*.c`)

- **Цель:** Изучить три разных способа организации ожидания с таймаутом.

- **Действия:**
    1. Изучите и соберите:
        - `timeout_poll.c` — ожидание на файловом дескрипторе.
        - `timeout_condvar.c` — межпоточное ожидание.
        - `timeout_mq.c` — межпроцессное ожидание.
    2. Реализуйте `timeout_ppoll.c`:
        - Создайте обработчик сигнала (например, `SIGUSR1`) и заблокируйте его с помощью `sigprocmask`.
        - Используйте `ppoll`, чтобы атомарно разблокировать сигнал на время ожидания события от файлового дескриптора.
        - Это продемонстрирует безопасную обработку сигналов.
    3. Опишите в комментариях к коду ключевые различия в API и сценарии применения каждого из четырех механизмов.

### Задание 4: Оптимизация для реального времени (`sched_fifo_jitter.c`)

- **Цель:** Измерить джиттер планировщика и применить техники для его уменьшения.

- **Действия:**
    1. Сначала запустите `sched_fifo_jitter.c` без изменений (под обычным планировщиком `SCHED_OTHER`). Замерьте и запишите статистику джиттера.
    2. Модифицируйте код, добавив в начало `main()`:
        - **Переключение планировщика:** `sched_setscheduler` для установки политики `SCHED_FIFO` с высоким приоритетом (например, 50).
        - **Блокировка памяти:** `mlockall(MCL_CURRENT | MCL_FUTURE)` для предотвращения откачки памяти процесса в swap.
        - **Привязка к ядру CPU:** `pthread_setaffinity_np` для закрепления потока на одном ядре (например, последнем доступном), чтобы избежать миграции.
    3. Запустите модифицированную версию (скорее всего, потребуются права `root` или специальные capabilities: `sudo ./bin/sched_fifo_jitter`).
    4. Сравните в комментариях к коду результаты "до" и "после". Объясните, как каждая из трёх техник (планировщик, блокировка памяти, привязка к ядру) способствует уменьшению джиттера.
