# Repository with laboratory work on the subject of Real-time systems
> Group: IA-331 | 
Student: Liubimov Kirill  
[Theory for laboratory works](https://gitverse.ru/aloshkarev/realtime-systems/content/master/tasks)

# Task 1:
## Задачи по организации доступа к общему ресурсу некоторого числа параллельных процессов

1. Выполнение программы "Hello World" (hello.c) 
2. Знакомство с организацией работы потоков, pthreads (intro.c)
3. Организация доступа к разделяемому ресурсу 
    - Дополнить код nomutex.c решением проблемы доступа к ресурсу с помощью мьютексов (mutex.c) 
    - Знакомство с организацией доступа к общему ресурсу с помощью семафоров (semex.c) 
    - Дополнить код condvar.c решением проблемы доступа к ресурсу с помощью условных переменных. Подробности задания в комментариях кода. (condvar.c)
    - Пример решения организации доступа в задаче "Производитель-потребитель" 
4. Инверсия приоритетов 
    - Используя исходные коды working.h, working.c, и scenario_1.c, проверить на практике пример возникновения проблемы "Инверсия приоритетов" 
    - Дополнить код scenario_2.c решением проблемы "Инверсия приоритетов" 
5. Прерывания 
    - Дополнить код intsimple.c возможностью обработки прерываний с клавиатуры и сигналов (SIGTERM, SIGKILL, SIGUSR1, SIGUSR2) (intsimple.c) 
6. Завершить разработку программы "Менеджер ресурсов" (Подробности задания в исходном коде). 
7. Проверить работу реализовав простой клиент. (resmgr.c)

# Task 2:
## Методы программирования в реальном времени для Linux
### Задание 1: Анализ системных часов (`calctime1.c`, `calctime2.c`)

- **Цель:** Понять разницу между `CLOCK_REALTIME` и `CLOCK_MONOTONIC`, научиться создавать стабильный периодический цикл с помощью `clock_nanosleep`.

- **Действия:**
    1. Изучите `calctime1.c` (предоставлен для анализа). Обратите внимание, как измеряется разрешение часов.
    2. Модифицируйте `calctime2.c`:
        - Реализуйте цикл, который просыпается каждые 2 миллисекунды с использованием  
        `clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ...)`.
        - Собирайте статистику реальных интервалов между пробуждениями (дельт).
        - Рассчитайте и выведите **min/max/avg** и **стандартное отклонение**, чтобы оценить стабильность периода.
    3. В комментариях к коду объясните, почему `TIMER_ABSTIME` критически важен для предотвращения накопления ошибки (дрейфа таймера).

### Задание 2: Периодический таймер на `timerfd` (`reptimer_timerfd.c`)

- **Цель:** Освоить современный Linux API (`timerfd`) для создания периодических событий без использования сигналов.

- **Действия:**
    1. Реализуйте программу, которая создает таймер `timerfd`.
    2. Настройте его на первое срабатывание через 5 секунд, а затем периодически каждые 1500 мс.
    3. В цикле ожидайте событий от таймера с помощью `read()` и выводите количество истечений и текущее время.
    4. В комментариях к коду сравните подходы с `clock_nanosleep` и `timerfd`. В каких случаях `timerfd` предпочтительнее? (Подсказка: интеграция с `epoll`).

---

### Задание 3: Стратегии обработки таймаутов (`timeout_*.c`)

- **Цель:** Изучить три разных способа организации ожидания с таймаутом.

- **Действия:**
    1. Изучите и соберите:
        - `timeout_poll.c` — ожидание на файловом дескрипторе.
        - `timeout_condvar.c` — межпоточное ожидание.
        - `timeout_mq.c` — межпроцессное ожидание.
    2. Реализуйте `timeout_ppoll.c`:
        - Создайте обработчик сигнала (например, `SIGUSR1`) и заблокируйте его с помощью `sigprocmask`.
        - Используйте `ppoll`, чтобы атомарно разблокировать сигнал на время ожидания события от файлового дескриптора.
        - Это продемонстрирует безопасную обработку сигналов.
    3. Опишите в комментариях к коду ключевые различия в API и сценарии применения каждого из четырех механизмов.

### Задание 4: Оптимизация для реального времени (`sched_fifo_jitter.c`)

- **Цель:** Измерить джиттер планировщика и применить техники для его уменьшения.

- **Действия:**
    1. Сначала запустите `sched_fifo_jitter.c` без изменений (под обычным планировщиком `SCHED_OTHER`). Замерьте и запишите статистику джиттера.
    2. Модифицируйте код, добавив в начало `main()`:
        - **Переключение планировщика:** `sched_setscheduler` для установки политики `SCHED_FIFO` с высоким приоритетом (например, 50).
        - **Блокировка памяти:** `mlockall(MCL_CURRENT | MCL_FUTURE)` для предотвращения откачки памяти процесса в swap.
        - **Привязка к ядру CPU:** `pthread_setaffinity_np` для закрепления потока на одном ядре (например, последнем доступном), чтобы избежать миграции.
    3. Запустите модифицированную версию (скорее всего, потребуются права `root` или специальные capabilities: `sudo ./bin/sched_fifo_jitter`).
    4. Сравните в комментариях к коду результаты "до" и "после". Объясните, как каждая из трёх техник (планировщик, блокировка памяти, привязка к ядру) способствует уменьшению джиттера.

# Task 3:
## Механизмы межзадачного взаимодействия
### Задание 1: POSIX Message Queues (`posix_mq_server.c`, `posix_mq_client.c`)

* **Цель:** Освоить стандартизированный, надежный, ориентированный на сообщения механизм IPC.

* **Действия:**

  1. Реализуйте пару программ: `posix_mq_server.c` и `posix_mq_client.c`.
  2. Клиент отправляет строку серверу.
  3. Сервер преобразует строку в верхний регистр и отправляет обратно через другую очередь, которую слушает клиент.
  4. Используйте сообщения с разными приоритетами: срочные сообщения обрабатываются раньше обычных.
  5. В комментариях к коду опишите плюсы и минусы MQ:

     * ограничения на размер и количество сообщений;
     * встроенные приоритеты и надежность доставки.

---

### Задание 2: Асинхронный сервер на `epoll` и `eventfd` (`epoll_server.c`)

* **Цель:** Построить каркас асинхронного сервера, способного эффективно управлять множеством клиентов и внутренними событиями.

* **Действия:**

  1. Создайте сервер, который слушает на UNIX-сокете.
  2. Используйте `epoll` для одновременного ожидания:

     * новых подключений;
     * данных от подключенных клиентов;
     * внутренних событий от других потоков сервера через `eventfd`.
  3. Реализуйте корректное обнаружение обрыва соединения: сервер должен удалить fd клиента из epoll и освободить ресурсы.
  4. В комментариях к коду объясните, почему `epoll` масштабируется лучше, чем `poll` или `select` при большом количестве соединений.

---

### Задание 3: Векторный ввод-вывод (`iov_demo.c`)

* **Цель:** Изучить механизм scatter-gather I/O (`readv`/`writev`) для атомарной передачи структурированных данных без лишних копирований.

* **Действия:**

  1. Определите структуру, состоящую из нескольких частей, например:

     ```c
     struct {
         uint32_t msg_type;
         uint64_t msg_id;
         char payload[128];
     };
     ```
  2. Заполните поля структуры.
  3. Создайте массив `struct iovec`, где каждый элемент указывает на одно из полей.
  4. Используя `writev`, отправьте всю структуру в pipe одним системным вызовом.
  5. На читающей стороне подготовьте `iovec` и прочтите данные в поля структуры с помощью `readv`.
  6. В комментариях к коду объясните выгоду `writev` по сравнению с ручным `memcpy` всех частей в единый буфер перед отправкой.

---

### Задание 4: Общая память и синхронизация (`shm_*.c`)

* **Цель:** Реализовать самый быстрый способ IPC через общую память и понять критическую важность синхронизации.

* **Действия:**

  1. Создайте общую структуру в заголовочном файле `shm_common.h`.
  2. Напишите `shm_producer.c`:

     * создаёт или открывает сегмент POSIX shared memory (`shm_open`, `mmap`);
     * циклически записывает данные (например, увеличивающийся счётчик).
  3. Напишите `shm_consumer.c`:

     * открывает тот же сегмент;
     * читает данные.
  4. Сначала запустите без синхронизации и зафиксируйте артефакты (пропуски, "рваные" чтения).
  5. Добавьте синхронизацию:

     * используйте именованные семафоры POSIX (`sem_open`, `sem_wait`, `sem_post`);
     * обеспечьте поочередный доступ производителя и потребителя.
  6. Проверьте корректность передачи данных с семафорами.
  7. В комментариях сравните оба запуска (без синхронизации и с ней).


# Task 4:
## Работа с устройствами
### Задание 1: Чтение событий с устройства ввода (`read_input.c`)

* **Цель:** Научиться работать с устройствами ввода в Linux и получать события напрямую из `/dev/input/eventX`.

* **Действия:**

  1. Напишите программу `read_input`, которая принимает путь к устройству ввода через аргумент командной строки.
  2. Откройте устройство с проверкой прав на чтение.
  3. В бесконечном цикле читайте структуры `struct input_event` и выводите поля: `type`, `code`, `value`.
  4. Используйте заголовочный файл `<linux/input.h>`.
  5. Для поиска нужного устройства выполните:

     ```bash
     cat /proc/bus/input/devices
     ```

     и найдите секцию вашей клавиатуры (строка `Handlers=eventX`).

---

### Задание 2: Использование `ioctl` для получения информации об устройстве (`read_input.c`)

* **Цель:** Научиться получать метаинформацию об устройстве ввода.

* **Действия:**

  1. Модифицируйте `read_input.c` перед чтением событий.
  2. Используйте `ioctl` с `EVIOCGNAME(len)`, чтобы получить и вывести имя устройства.
  3. Попробуйте также получить физический путь устройства через `EVIOCGPHYS(len)`.
  4. Корректно обрабатывайте ошибки `ioctl`.
  5. В комментариях объясните назначение получаемой информации.

---

### Задание 3: Мониторинг нескольких устройств с помощью `poll` (`poll_inputs.c`)

* **Цель:** Освоить одновременное чтение нескольких устройств ввода с использованием `poll`.

* **Действия:**

  1. Напишите новую программу `poll_inputs`, принимающую несколько путей к устройствам через аргументы командной строки:

     ```bash
     ./poll_inputs /dev/input/event2 /dev/input/event4
     ```
  2. Для каждого устройства откройте файловый дескриптор.
  3. Используйте `poll()` для ожидания событий на любом из дескрипторов.
  4. При уведомлении от `poll()` определите, на каком fd произошло событие.
  5. Прочитайте `struct input_event` и выведите поля `type`, `code`, `value`.
  6. Для каждого события также выведите **имя устройства**, используя `ioctl` из Задания 2.
  7. В комментариях к коду поясните, почему `poll` удобен для мониторинга множества устройств одновременно, в отличие от последовательного чтения.

# Task 5:
## Управление памятью в системах реального времени
### Задание 1: Демонстрация влияния Page Faults (`pagefault_demo.c`)

* **Цель:** Показать, как отложенные ошибки страниц (page faults) влияют на задержки доступа к памяти.

* **Действия:**

  1. Выделите большой массив (например, 512 МБ) через `malloc`.
  2. В цикле (например, 1000 итераций) обращайтесь к элементам массива с шагом, превышающим размер страницы (`i += 4096`).
  3. На каждой итерации измеряйте:

     * латентность доступа к памяти с помощью `clock_gettime(CLOCK_MONOTONIC, ...)`;
     * количество minor и major page faults через `getrusage(RUSAGE_SELF, ...)`.
  4. Выводите в консоль или лог: номер итерации, латентность (нс) и общее число отказов.
  5. Постройте график зависимости латентности от итерации и отметьте "шипы", соответствующие page faults.

---

### Задание 2: Устранение Page Faults с помощью `mlockall` (`pagefault_mlock.c`)

* **Цель:** Снизить задержки и сделать их предсказуемыми, устранив задержки, вызванные page faults.

* **Действия:**

  1. Модифицируйте программу из Задания 1.
  2. В начале программы вызовите:

     ```c
     mlockall(MCL_CURRENT | MCL_FUTURE);
     ```

     Для этого могут потребоваться права суперпользователя (`sudo`).
  3. После выделения массива, но до измерений, выполните "прогрев" памяти:

     * пройдитесь по всему массиву с шагом в размер страницы;
     * запишите по одному байту в каждую страницу.
  4. Запустите цикл измерений аналогично Заданию 1.
  5. Сравните результаты, приведите два графика (до и после) и объясните снижение задержек и предсказуемость.

---

### Задание 3: Реализация и бенчмарк пула памяти (`mempool.h`, `mempool.c`, `task3_benchmark.c`)

* **Цель:** Создать собственный менеджер памяти с низким джиттером и сравнить его с `malloc`.

* **Действия:**

  1. Создайте пул фиксированных блоков:

     * `pool_create(size_t block_size, size_t block_count)` — выделяет память, блокирует через `mlock`, формирует связный список свободных блоков;
     * `pool_alloc(pool_t* pool)` — возвращает свободный блок (O(1));
     * `pool_free(pool_t* pool, void* block)` — возвращает блок в пул (O(1));
     * `pool_destroy(pool_t* pool)` — освобождает всю память пула.
  2. Напишите бенчмарк `task3_benchmark.c`:

     * создаёт пул;
     * выполняет в цикле (например, 1 000 000 раз) `pool_alloc` → `pool_free`, измеряет максимальную задержку и джиттер;
     * выполняет аналогичный цикл с `malloc` → `free` и сравнивает показатели.
  3. В отчёте сравните результаты и сделайте вывод о предсказуемости работы собственного пула vs. стандартного аллокатора.

# Task 6:
## Управление привязкой к CPU и изоляция ресурсов
### Задание 1: Измерение джиттера в условиях системного шума (`jitter_measure.c`)

* **Цель:** Оценить стабильность выполнения вычислительных задач в условиях фоновой нагрузки.

* **Действия:**

  1. Реализуйте CPU-bound функцию (например, перемножение матриц 10x10 или итерационный расчёт числа Пи).
  2. В главном цикле (1000+ итераций) вызывайте функцию и измеряйте время её выполнения с помощью `clock_gettime`.
  3. Собирайте статистику: минимальное, максимальное, среднее время, стандартное отклонение или разницу max-min как показатель джиттера.
  4. Установите высокий приоритет реального времени для процесса, например:

     ```c
     sched_setscheduler(0, SCHED_FIFO, &param);
     ```

     с приоритетом 50.
  5. Запустите программу одновременно со скриптом `noise.sh`, создающим фоновую нагрузку.
  6. Зафиксируйте результаты, особенно максимальное время выполнения и джиттер.

---

### Задание 2: Применение CPU Affinity для снижения джиттера (`jitter_affinity.c`)

* **Цель:** Снизить джиттер, ограничив миграцию процесса между ядрами.

* **Действия:**

  1. Модифицируйте программу из Задания 1.
  2. Выберите ядро для эксперимента (например, ядро №1).
  3. С помощью `CPU_ZERO`, `CPU_SET` и `sched_setaffinity` привяжите процесс к выбранному ядру.
  4. Повторите измерения из Задания 1 с запущенным `noise.sh`.
  5. Сравните результаты "до" и "после":

     * объясните, почему джиттер уменьшился, но не исчез полностью;
     * отметьте влияние системного шума и планировщика.

# Task 7:
## Моделирование системы управления перекрестком
### Задание 1: Ядро контроллера и конечный автомат (`traffic_controller.c`, `common.h`)

* **Цель:** Реализовать базовую логику переключения светофоров с использованием конечного автомата и POSIX таймеров.

* **Действия:**

  1. **Определите состояния:**
     В файле `common.h` создайте `enum` для всех состояний светофоров, например:

     ```c
     STATE_NS_GREEN,
     STATE_NS_YELLOW,
     STATE_EW_GREEN,
     STATE_EW_YELLOW,
     STATE_ALL_RED
     ```
  2. **Реализуйте FSM:**
     В потоке контроллера используйте `switch-case` или массив функций-обработчиков для каждого состояния.
  3. **Используйте POSIX таймер:**

     * Создайте таймер через `timer_create`.
     * Используйте сигнал (например, `SIGRTMIN`) для уведомления о срабатывании.
     * В обработчике сигнала безопасно уведомляйте главный цикл контроллера (например, через `volatile sig_atomic_t` флаг).
  4. **Тайминги состояний:**

     * При входе в состояние (например, `STATE_NS_GREEN`) устанавливайте таймер `timer_settime` на нужную длительность (например, 10 секунд для зелёного, 2 секунды для жёлтого).
  5. **Визуализация:**

     * При каждой смене состояния выводите в консоль текущее состояние и цвета светофоров (NS: Green, EW: Red).

---

### Задание 2: Интерактивность и асинхронные события (`traffic_input.c`)

* **Цель:** Добавить взаимодействие с пользователем и обработку внештатных ситуаций.

* **Действия:**

  1. **Поток ввода:**

     * Создайте второй поток, который в цикле ожидает ввод с клавиатуры (`getchar`).
     * Используйте мьютекс для потокобезопасной работы с флагами.
  2. **Запрос пешехода:**

     * Обрабатывайте нажатия:

       * `'n'` — пешеход на NS;
       * `'e'` — пешеход на EW.
     * Поток ввода выставляет флаг запроса пешехода.
     * FSM в контроллере проверяет флаг перед переключением на зелёный и при необходимости переходит в `STATE_PED_CROSS` (всем красный, надпись "WALK") на 10 секунд, затем сбрасывает флаг.
  3. **Режим чрезвычайной ситуации (ЧС) (`*`):**

     * Обрабатывайте нажатие `'s'` (siren) с наивысшим приоритетом.
     * Независимо от текущего состояния, контроллер немедленно переходит в `STATE_ALL_RED`.
     * Система остаётся в этом состоянии, пока пользователь не нажмёт `'s'` снова.
     * Для немедленного прерывания ожидания используйте `pthread_cond_signal` или `timer_settime` с нулевым временем.

* **Комментарий:**
  Такой подход моделирует реальную логику перекрестка с асинхронными событиями, приоритетами и безопасным управлением состояниями через FSM и POSIX таймеры.
